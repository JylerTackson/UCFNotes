### Definition of a Regular Expression:
$R$ is a **regular expression** over the alphabet $\Sigma$ if it is:
1) a for some $a\in\Sigma$
2) $\lambda$
3) $\emptyset$
4) $(R_1\cup R_2)$ where $R_1$ and $R_2$ are both regular expressions:
	- Note: $R_1 \cup R_2 == R_1 + R_2$
5) $(R_1 \cdot R_2)$ where $R_1$ and $R_2$ are both regular expression.
6) $(R_1^*)$ where $R_1$ is a regular expression
1-3 represent the languages:
- $\{a\}$
- $\{\lambda\}$
- $\{\emptyset\}$
4-6 represent the **union $(\cup)$, star closure $(*)$, and concatenation $(\cdot)$** described by the regular expression operands.

In general, for a regular expression describing a language over the alphabet, we write:
- A symbol to represent the language containing the string consisting of itself
- $(a\cup b)$ to represent either of symbols a or b
- $a \cdot b$ or $ab$ to represent symbol $a$ concatenated with $b$
- $\Sigma$ to represent any symbol from $\Sigma$
- $a^*$ represents zero or more occurrences of a
- $\Sigma^*$ represents zero or more occurrences of ANY symbol from $\Sigma$
We extend all of these as normal - we can union, concatenate, and star-close any regular expressions.
- **Star closure** has **precedence** over **concatenation**
- **Concatenation** has **precedence** over **union**


### Regular Expressions Practice
#### Example 1:
Give a language description based on the regular expression with $\Sigma = \{0,1\}$
1) Expression:
	- $\mathbf{r_a=0^* 1\; 0^*}$
		- To describe this language we can write:
			- $L_1=\{0^n 1\; 0^m:n\geq0,m\geq0\}$
			- $L_2=\{w:w\in\Sigma^* \text{ and }w\text{ contains a single }1\}$
	- $\mathbf{r_b=\Sigma^* 1 \;\Sigma^*}$
		- To describe this language we can write:
			- $L_1=\{w:w\in\Sigma^* \text{ and w contains atleast one }1\}$
	- $\mathbf{r_c=\Sigma^* 001 \; \Sigma^*}$
		- To describe this language we can write:
			- $L_1=\{w:w\in \Sigma^* \text{ and contains substring }001\}$
	- $\mathbf{r_d=(0\Sigma^*0) \cup (1\Sigma^* 1) \cup (0) \cup (1)}$
		- The $\cup$ operator here is stating that the expression generated by this MUST satisfy 1/4 of the shown expressions. It does NOT need to satisfy all of them, just one of them to be understood by the generated language.
		- To describe this language we can write:
			- $L_1=\{w:w \text{ starts/ends w/ same symbol}\}$
	- $\mathbf{r_e=1^*\emptyset}$
		- When we concatenate with the empty set, we will always return the empty set
			- Like multiplying by 0
		- To describe this language we can write:
			- $L_1=\emptyset$
	- $\mathbf{r_f=\emptyset^*=\lambda}$
		- The empty set is just the empty string
		- To describe this language we can write:
			- $L_1=\lambda$


#### Convert the following regular expressions into an NFA:
1) $r_a = a$
	- The expression says that it is equal to the symbol `a`
	![[Pasted image 20250607210258.png]]
2) $r_b=a\cup b$
	- The expression says that it is equal to the symbols `a` OR `b`
	![[Pasted image 20250607210438.png]]
3) $r_c=(a\cup b)^*$
	- The expression is saying it will be a combination of a's OR b's
		- The * is indicating a cycle within the parenthesis
		- Since we are using * we know that a string it can generate is the $\lambda$
	![[Pasted image 20250607211206.png]]

# GNFA
A GNFA is a **special kind of NFA** that uses regular expressions as its *transition alphabet*
- A GNFA has a **single start & accept state**
- Nothing can transition **into** the start state, meanwhile, nothing can transition **out** of the accept state.
	1) Convert the DFA to a GNFA
	2) Convert the GNFA to a regular expression by **state ripping and repair**
		1) One by one, remove states.
		2) Expend the expressions on the transitions surround the removed state.
	3) You know you are finished when there are only two states left: the **start and accept**.
	4) The transition from start to accept will be the whole regular expression.

#### Example:
Assume you are given the NFA below and you have to transfer it to a GNFA
![[Pasted image 20250607215757.png]]

##### 1) Place your START and ACCEPT states:
A GNFA can only have ONE start and accept state. We place the start state connecting to the previous start state with a lambda transition and the similar thing for the accept state.
![[Pasted image 20250607220224.png]]

##### 2) Remove and Repair
1) The first node to remove will be $q_2$. You will remove the node and re-append the connections to the append state:
	- There are three expressions we are removing and must repair:
		- $b$
		- $a\cup b$
		- $\lambda$
	- By creating an equivalent expression that comprises these three we can replace these three with one by using:
		- $b(a\cup b)^*$
	![[Pasted image 20250607220652.png]]

2) The next node to remove is $q_1$:
	- There are three expressions we must consider here:
		- $\lambda$
		- $a$
		- $b(a\cup b)^*$
	- By creating the equivalent expression we can show:
		- $a^*b(a\cup b)^*$
	![[Pasted image 20250607220951.png]]

